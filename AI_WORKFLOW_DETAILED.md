# AI Workflow Chi Ti·∫øt - T·ª´ Input ƒê·∫øn Response

## T·ªïng quan lu·ªìng x·ª≠ l√Ω

Khi ng∆∞·ªùi d√πng nh·∫≠p tin nh·∫Øn v√†o chatbot, h·ªá th·ªëng s·∫Ω tr·∫£i qua nhi·ªÅu b∆∞·ªõc x·ª≠ l√Ω ph·ª©c t·∫°p ƒë·ªÉ ƒë·∫£m b·∫£o ph·∫£n h·ªìi ch√≠nh x√°c v√† ph√π h·ª£p nh·∫•t.

---

## üìù WORKFLOW CHI TI·∫æT T·ª™NG B∆Ø·ªöC

### **GIAI ƒêO·∫†N 1: FRONTEND - Ng∆∞·ªùi d√πng nh·∫≠p tin nh·∫Øn**

#### B∆∞·ªõc 1.1: User Interface (chatbot.js)
```
Ng∆∞·ªùi d√πng g√µ tin nh·∫Øn ‚Üí Nh·∫•n Enter/Click Send
‚Üì
chatbot.js: sendMessage()
‚Üì
- L·∫•y message t·ª´ input field
- Validate message (kh√¥ng r·ªóng)
- Display user message l√™n UI ngay l·∫≠p t·ª©c
- Clear input field
- Show typing indicator
- Call sendMessageToApi()
```

**Code example:**
```javascript
async function sendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    displayMessage('user', message);           // Hi·ªÉn th·ªã ngay
    chatInput.value = '';                     // X√≥a input
    showTyping(true);                          // Show "AI ƒëang g√µ..."
    await sendMessageToApi(message);           // G·ªçi API
}
```

#### B∆∞·ªõc 1.2: API Request (chatbot.js)
```
Fetch POST request to /api/ai/chat/enhanced
‚Üì
Body: {
    message: "User's message",
    userId: USER_ID,
    sessionId: getCurrentSessionId()
}
‚Üì
Headers: Content-Type: application/json
```

---

### **GIAI ƒêO·∫†N 2: BACKEND - X·ª≠ l√Ω request**

#### B∆∞·ªõc 2.1: Controller Entry Point (EnhancedAIController.java)
```
Request ƒë·∫øn ‚Üí EnhancedAIController.chat()
‚Üì
- Validate session authentication
- Extract userId t·ª´ HTTP session
- Validate request body
```

#### B∆∞·ªõc 2.2: Rate Limiting Check
```java
// Ki·ªÉm tra rate limit cho userId
if (!rateLimitingService.isAllowed(userId, RateLimitType.AI_CHAT)) {
    return ResponseEntity.status(429).body(
        new ChatReply("Rate limit exceeded...", false, LocalDateTime.now())
    );
}
```

**Rate Limiting:** Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng request ƒë·ªÉ tr√°nh spam v√† t·ªëi ∆∞u server

#### B∆∞·ªõc 2.3: Input Validation & Sanitization
```java
// Validate v√† sanitize input
ValidationResult validation = securityService.validateInput(
    req.message(), 
    InputType.MESSAGE
);

if (!validation.isValid()) {
    return ResponseEntity.badRequest().body(
        new ChatReply("‚ùå " + validation.getErrorMessage(), false, LocalDateTime.now())
    );
}
```

**Validation checks:**
- ‚úÖ Kh√¥ng r·ªóng
- ‚úÖ ƒê·ªô d√†i h·ª£p l·ªá (kh√¥ng qu√° 1000 k√Ω t·ª±)
- ‚úÖ Kh√¥ng ch·ª©a script injection
- ‚úÖ Kh√¥ng ch·ª©a SQL injection patterns
- ‚úÖ Format h·ª£p l·ªá

---

### **GIAI ƒêO·∫†N 3: LANGUAGE PROCESSING - X·ª≠ l√Ω ng√¥n ng·ªØ**

#### B∆∞·ªõc 3.1: Language Detection
```java
// Detect ng√¥n ng·ªØ c·ªßa tin nh·∫Øn
Language userLanguage = languageDetectionService.detectLanguage(req.message());
```

**Supported languages:** Vietnamese, English, Chinese, Japanese, Korean, French, German, Spanish, Thai, Indonesian, etc.

**Detection method:** S·ª≠ d·ª•ng library language detection d·ª±a tr√™n:
- Character patterns
- Common words
- Statistical analysis

#### B∆∞·ªõc 3.2: Translation to Vietnamese
```java
// D·ªãch sang ti·∫øng Vi·ªát ƒë·ªÉ AI x·ª≠ l√Ω
String processedMessage = validation.getSanitizedInput();
if (userLanguage != Language.VIETNAMESE) {
    processedMessage = translationService.translateUserInput(processedMessage, userLanguage);
}
```

**Translation service:**
- Primary: LibreTranslate API
- Fallback: Multiple fallback URLs
- Cache: In-memory cache ƒë·ªÉ tƒÉng performance
- Async: Non-blocking translation

---

### **GIAI ƒêO·∫†N 4: AI PROCESSING - X·ª≠ l√Ω b·∫±ng AI**

#### B∆∞·ªõc 4.1: Chat Session Service
```java
// T·∫°o ChatRequest v·ªõi message ƒë√£ d·ªãch
ChatRequest processedReq = new ChatRequest(
    processedMessage,      // Message ƒë√£ translate
    userId,                // User ID
    sessionId              // Session ID
);

// Process chat
ChatReply reply = chatSessionService.chat(processedReq);
```

#### B∆∞·ªõc 4.2: Event AI Agent Processing (EventAIAgent.java)

##### **4.2.1: Context Building**
```java
// X√¢y d·ª±ng context t·ª´ conversation history
List<Message> context = buildConversationContext(sessionId, userId);
```

**Context includes:**
- System prompt (instructions cho AI)
- Recent 10 messages t·ª´ conversation history
- Current date/time
- User information

##### **4.2.2: Intent Classification**
```java
// T·∫°o embedding cho user input
float[] userVector = embeddingService.getEmbedding(userInput);

// Classify intent
ActionType intent = classifier.classifyIntent(userInput, userVector);
```

**Possible intents:**
- `BUY_TICKET` - Mua v√©
- `QUERY_TICKET_INFO` - Xem th√¥ng tin v√©
- `ADD_EVENT` - T·∫°o s·ª± ki·ªán
- `UPDATE_EVENT` - S·ª≠a s·ª± ki·ªán
- `DELETE_EVENT` - X√≥a s·ª± ki·ªán
- `SET_REMINDER` - ƒê·∫∑t nh·∫Øc nh·ªü
- `PROMPT_FREE_TIME` - T√¨m th·ªùi gian r·∫£nh
- `PROMPT_SUMMARY_TIME` - T√≥m t·∫Øt l·ªãch
- `CONFIRM_ORDER` - X√°c nh·∫≠n ƒë∆°n h√†ng
- `CANCEL_ORDER` - H·ªßy ƒë∆°n h√†ng
- `UNKNOWN` - Kh√¥ng r√µ

##### **4.2.3: Special Flow Checks**

**A. Order Flow (Mua v√©)**
```java
if (intent == ActionType.BUY_TICKET) {
    // T√¨m s·ª± ki·ªán
    List<Event> foundEvents = eventVectorSearchService.searchEvents(userInput, userId, 1);
    
    // Start order creation
    return orderAIService.startOrderCreation(userId, eventName);
}

// Check pending order
if (orderAIService.hasPendingOrder(userId)) {
    PendingOrder pending = orderAIService.getPendingOrder(userId);
    
    switch (pending.getCurrentStep()) {
        case SELECT_TICKET_TYPE:
            return orderAIService.selectTicketType(userId, userInput);
        case PROVIDE_INFO:
            return orderAIService.provideInfo(userId, info);
        case CONFIRM_ORDER:
            return handleConfirmation(userId, userInput);
    }
}
```

**B. Out of Scope Check**
```java
// Ki·ªÉm tra c√¢u h·ªèi c√≥ ngo√†i ph·∫°m vi kh√¥ng
if (isOutOfScope(userInput)) {
    return handleOutOfScopeQuestion();
}
```

**C. Weather Question Check**
```java
// Ki·ªÉm tra c√¢u h·ªèi v·ªÅ th·ªùi ti·∫øt
if (isWeatherQuestion(userInput)) {
    return handleWeatherQuestion(userInput);
}
```

##### **4.2.4: LLM Processing**
```java
// Th√™m user message v√†o context
context.add(new Message("user", userInput));

// Call LLM API ƒë·ªÉ generate response
String aiResponse = llm.generateResponse(context);
```

**LLM Processing:**
- Model: Qwen/Qwen3-Embedding-8B
- API: HuggingFace API
- Input: Full conversation context
- Output: Natural language response

##### **4.2.5: Action Parsing**
```java
// Parse JSON actions t·ª´ LLM response
Pattern jsonPattern = Pattern.compile("(\\[\\s*\\{[\\s\\S]*?\\}\\s*\\])");
Matcher matcher = jsonPattern.matcher(aiResponse);
String jsonPart = matcher.find() ? matcher.group() : null;

// Parse actions
List<Action> actions = tryParseActions(jsonPart);
```

**Action types:**
- `ADD_EVENT` - T·∫°o s·ª± ki·ªán m·ªõi
- `UPDATE_EVENT` - C·∫≠p nh·∫≠t s·ª± ki·ªán
- `DELETE_EVENT` - X√≥a s·ª± ki·ªán
- `SET_REMINDER` - ƒê·∫∑t nh·∫Øc nh·ªü

##### **4.2.6: Action Execution**

**Example: ADD_EVENT action**
```java
case "ADD_EVENT" -> {
    Map<String, Object> args = action.getArgs();
    
    // Extract event information
    String title = getStr(args, "title", "event_title");
    LocalDateTime start = getTime(args, "start_time", "starts_at");
    LocalDateTime end = getTime(args, "end_time", "ends_at");
    String placeName = getStr(args, "place", "location");
    
    // Validation
    if (title == null || start == null || end == null) {
        systemResult.append("üìù Thi·∫øu th√¥ng tin s·ª± ki·ªán");
        break;
    }
    
    // Check time conflict
    List<Event> conflicted = eventService.isTimeConflict(start, end, List.of(place));
    if (!conflicted.isEmpty()) {
        systemResult.append("‚ö†Ô∏è S·ª± ki·ªán b·ªã tr√πng th·ªùi gian");
        break;
    }
    
    // Weather check for outdoor events
    if (isOutdoorEvent) {
        String forecast = weatherService.getForecastNote(start, location);
        if (forecast.contains("rain")) {
            pendingEvents.put(sessionId, new PendingEvent(event));
            return "üå¶ Th·ªùi ti·∫øt c√≥ th·ªÉ m∆∞a. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?";
        }
    }
    
    // Create event
    Event saved = agentEventService.createEventByCustomer(userId, event, orgId);
    systemResult.append("‚úÖ ƒê√£ th√™m s·ª± ki·ªán: " + saved.getTitle());
}
```

**Example: SET_REMINDER action**
```java
case "SET_REMINDER" -> {
    Long remindMinutes = getLong(args, "remind_minutes");
    String eventTitle = getStr(args, "event_title");
    
    // T√¨m s·ª± ki·ªán
    Optional<Event> targetEvent = findEventByName(eventTitle);
    
    // Get user email
    String userEmail = getCustomerEmail(userId);
    
    // Save reminder
    agentEventService.createOrUpdateEmailReminder(eventId, remindMinutes, userId);
    
    systemResult.append("‚úÖ ƒê√£ ƒë·∫∑t l·ªãch nh·∫Øc nh·ªü tr∆∞·ªõc " + remindMinutes + " ph√∫t");
}
```

---

### **GIAI ƒêO·∫†N 5: RESPONSE GENERATION - T·∫°o ph·∫£n h·ªìi**

#### B∆∞·ªõc 5.1: Response Assembly
```java
// Combine text response v√† action results
String fullResponse = userVisibleText + "\n\n" + systemResult;
if (shouldReload) {
    fullResponse += "\n__RELOAD__";  // Flag ƒë·ªÉ reload page
}
return fullResponse;
```

#### B∆∞·ªõc 5.2: Translate Response
```java
// D·ªãch ph·∫£n h·ªìi v·ªÅ ng√¥n ng·ªØ c·ªßa user
String translatedResponse = reply.message();
if (userLanguage != Language.VIETNAMESE) {
    translatedResponse = translationService.translateAIResponse(
        reply.message(), 
        userLanguage
    );
}
```

#### B∆∞·ªõc 5.3: Response Validation
```java
// Validate AI response
ValidationResult responseValidation = securityService.validateAIResponse(translatedResponse);
if (!responseValidation.isValid()) {
    translatedResponse = "‚ùå " + responseValidation.getErrorMessage();
}
```

#### B∆∞·ªõc 5.4: Database Storage
```java
// L∆∞u user message v√†o database
ChatMessage userMessage = new ChatMessage();
userMessage.setSessionId(sessionId);
userMessage.setUserId(userId);
userMessage.setMessage(message);
userMessage.setIsFromUser(true);
userMessage.setTimestamp(LocalDateTime.now());
chatMessageRepo.save(userMessage);

// L∆∞u AI response v√†o database
ChatMessage aiMessage = new ChatMessage();
aiMessage.setSessionId(sessionId);
aiMessage.setUserId(userId);
aiMessage.setMessage(reply.message());
aiMessage.setIsFromUser(false);
aiMessage.setTimestamp(LocalDateTime.now());
chatMessageRepo.save(aiMessage);
```

---

### **GIAI ƒêO·∫†N 6: FRONTEND - Hi·ªÉn th·ªã response**

#### B∆∞·ªõc 6.1: Response Processing (chatbot.js)
```javascript
const data = await response.json();
showTyping(false);

// Ki·ªÉm tra n·∫øu c·∫ßn reload page
if (data.message && data.message.includes("__RELOAD__")) {
    const cleanMessage = data.message.replace("__RELOAD__", "").trim();
    displayMessage('bot', cleanMessage);
    setTimeout(() => location.reload(), 1500);
} else {
    displayMessage('bot', data.message || 'Xin l·ªói...');
}
```

#### B∆∞·ªõc 6.2: Display Message
```javascript
function displayMessage(sender, message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    // Format message (markdown support)
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.innerHTML = formatMessage(message);
    
    // Append to chat
    chatMessages.appendChild(messageDiv);
    scrollToBottom();
}

function formatMessage(message) {
    // Support markdown: **bold**, *italic*, newlines
    return message
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
}
```

---

## üéØ C√ÅC C√ÅCH AI PH·∫¢N H·ªíI

H·ªá th·ªëng AI c√≥ nhi·ªÅu c√°ch ph·∫£n h·ªìi kh√°c nhau t√πy thu·ªôc v√†o intent v√† context:

### **1. PH·∫¢N H·ªíI T·ª∞ NHI√äN (Natural Conversation)**
```
User: "Xin ch√†o"
AI: "Xin ch√†o! T√¥i l√† OpenEventAI, tr·ª£ l√Ω th√¥ng minh c·ªßa b·∫°n. 
     T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m ki·∫øm s·ª± ki·ªán, ƒë·∫∑t v√©, v√† nhi·ªÅu h∆°n n·ªØa!"
```

### **2. PH·∫¢N H·ªíI V·ªöI H√ÄNH ƒê·ªòNG (Action-based)**
```
User: "T·∫°o s·ª± ki·ªán Music Night v√†o 20h ng√†y 15/12 t·∫°i Nh√† vƒÉn h√≥a"
AI: "‚úÖ ƒê√£ t·∫°o s·ª± ki·ªán 'Music Night' v√†o 20:00 ng√†y 15/12/2024"
```

### **3. PH·∫¢N H·ªíI V·ªöI X√ÅC NH·∫¨N (Confirmation)**
```
User: "T·∫°o s·ª± ki·ªán ngo√†i tr·ªùi"
AI: "üå¶ D·ª± b√°o c√≥ th·ªÉ m∆∞a v√†o th·ªùi gian n√†y. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng?"
```

### **4. PH·∫¢N H·ªíI TH√îNG TIN (Information)**
```
User: "Xem v√© s·ª± ki·ªán Music Night"
AI: "üé´ Th√¥ng tin v√© cho s·ª± ki·ªán: Music Night
     ‚Ä¢ V√© th∆∞·ªùng: 100,000 VNƒê (C√≤n l·∫°i: 50 v√©)
     ‚Ä¢ V√© VIP: 200,000 VNƒê (C√≤n l·∫°i: 10 v√©)"
```

### **5. PH·∫¢N H·ªíI H∆Ø·ªöNG D·∫™N (Guidance)**
```
User: "L√†m sao ƒë·ªÉ mua v√©?"
AI: "Em h∆∞·ªõng d·∫´n b·∫°n mua v√© nh∆∞ sau:
     1Ô∏è‚É£ Cho t√¥i bi·∫øt t√™n s·ª± ki·ªán mu·ªën tham gia
     2Ô∏è‚É£ T√¥i s·∫Ω hi·ªÉn th·ªã t·∫•t c·∫£ lo·∫°i v√© v·ªõi gi√° v√† s·ªë l∆∞·ª£ng
     3Ô∏è‚É£ B·∫°n ch·ªçn lo·∫°i v√© ph√π h·ª£p
     4Ô∏è‚É£ Cung c·∫•p th√¥ng tin: t√™n, email, s·ªë ƒëi·ªán tho·∫°i
     5Ô∏è‚É£ X√°c nh·∫≠n ƒë∆°n h√†ng
     6Ô∏è‚É£ Thanh to√°n qua PayOS"
```

### **6. PH·∫¢N H·ªíI L·ªñI (Error)**
```
User: "T·∫°o s·ª± ki·ªán v√†o qu√° kh·ª©"
AI: "‚õî Th·ªùi gian kh√¥ng h·ª£p l·ªá: s·ª± ki·ªán kh√¥ng th·ªÉ ·ªü qu√° kh·ª©"
```

### **7. PH·∫¢N H·ªíI C·∫¢NH B√ÅO (Warning)**
```
User: "T·∫°o s·ª± ki·ªán tr√πng th·ªùi gian"
AI: "‚ö†Ô∏è S·ª± ki·ªán b·ªã tr√πng th·ªùi gian v·ªõi:
     - S·ª± ki·ªán ABC (20:00 - 22:00)
     B·∫°n c√≥ mu·ªën ch·ªçn th·ªùi gian kh√°c kh√¥ng?"
```

### **8. PH·∫¢N H·ªíI MULTI-STEP (Quy tr√¨nh nhi·ªÅu b∆∞·ªõc)**
```
Step 1 - User: "Mua v√©"
         AI: "üé´ S·ª± ki·ªán: Music Night
              C√°c lo·∫°i v√© c√≥ s·∫µn:
              ‚Ä¢ V√© th∆∞·ªùng: 100,000 VND
              ‚Ä¢ V√© VIP: 200,000 VND
              B·∫°n mu·ªën ch·ªçn lo·∫°i v√© n√†o?"

Step 2 - User: "V√© VIP"
         AI: "‚úÖ ƒê√£ ch·ªçn v√© VIP - Gi√°: 200,000 VND
              Vui l√≤ng cung c·∫•p th√¥ng tin:
              - T√™n ng∆∞·ªùi tham gia
              - Email
              - S·ªë ƒëi·ªán tho·∫°i"

Step 3 - User: "T√™n: Nguy·ªÖn VƒÉn A, Email: test@gmail.com"
         AI: "üìã X√°c nh·∫≠n th√¥ng tin ƒë∆°n h√†ng:
              üé´ S·ª± ki·ªán: Music Night
              üéüÔ∏è Lo·∫°i v√©: VIP
              üí∞ Gi√°: 200,000 VND
              üë§ T√™n: Nguy·ªÖn VƒÉn A
              üìß Email: test@gmail.com
              üí° X√°c nh·∫≠n ƒë·∫∑t v√©? (C√≥/Kh√¥ng)"

Step 4 - User: "C√≥"
         AI: "‚úÖ ƒê√£ t·∫°o ƒë∆°n h√†ng th√†nh c√¥ng!
              üîó Link thanh to√°n: https://payos.com/..."
```

### **9. PH·∫¢N H·ªíI V·ªöI LINK (Payment/Rerload)**
```
User: "X√°c nh·∫≠n mua v√©"
AI: "‚úÖ ƒê√£ t·∫°o ƒë∆°n h√†ng th√†nh c√¥ng!
     üîó Link thanh to√°n: https://payos.com/checkout/12345
     
     üí° Vui l√≤ng thanh to√°n ƒë·ªÉ ho√†n t·∫•t ƒëƒÉng k√Ω."
```

### **10. PH·∫¢N H·ªíI NGO√ÄI PH·∫†M VI (Out of Scope)**
```
User: "L·ªãch s·ª≠ Vi·ªát Nam nh∆∞ th·∫ø n√†o?"
AI: "Xin l·ªói, t√¥i ch·ªâ c√≥ th·ªÉ h·ªó tr·ª£ v·ªÅ h·ªá th·ªëng OpenEvent v√† c√°c s·ª± ki·ªán th√¥i.
     
     Em c√≥ th·ªÉ gi√∫p b·∫°n:
     ‚úÖ T√¨m ki·∫øm s·ª± ki·ªán
     ‚úÖ Mua v√© s·ª± ki·ªán
     ‚úÖ T·∫°o v√† qu·∫£n l√Ω s·ª± ki·ªán
     ‚úÖ Xem th√¥ng tin v·ªÅ speakers v√† ƒë·ªãa ƒëi·ªÉm
     
     B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ v·ªÅ OpenEvent ·∫°? üòä"
```

### **11. PH·∫¢N H·ªíI V·ªöI LOADER (Reload Page)**
```
User: "T·∫°o s·ª± ki·ªán v√† reload"
AI: "‚úÖ ƒê√£ t·∫°o s·ª± ki·ªán th√†nh c√¥ng!
     [Auto reload page after 1.5s]"
```

---

## üîÑ ERROR HANDLING & RETRY MECHANISMS

### **Retry Strategy**
```javascript
async function sendMessageToApi(message, retryCount = 0) {
    try {
        const response = await fetch(API_ENDPOINT, {...});
        // Success
    } catch (error) {
        if (retryCount < 2 && !isAuthError) {
            // Retry with exponential backoff
            setTimeout(() => {
                sendMessageToApi(message, retryCount + 1);
            }, 2000 * (retryCount + 1));
        } else {
            // Show error with retry button
            displayErrorWithRetryButton();
        }
    }
}
```

### **Error Types**
- **400**: Invalid data ‚Üí "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá"
- **401**: Unauthenticated ‚Üí "Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n"
- **403**: Forbidden ‚Üí "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p"
- **429**: Rate limit ‚Üí "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu tin nh·∫Øn"
- **500**: Server error ‚Üí "L·ªói m√°y ch·ªß"
- **503**: Service unavailable ‚Üí "D·ªãch v·ª• t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng"

---

## üìä PERFORMANCE METRICS

- **Response Time**: ~1-3 seconds (average)
- **Translation Time**: ~200-500ms (cached)
- **LLM Processing**: ~1-2 seconds
- **Database Operations**: ~50-100ms

---

## üîê SECURITY FEATURES

1. **Rate Limiting**: Prevent spam v√† abuse
2. **Input Validation**: Sanitize user input
3. **SQL Injection Prevention**: Parameterized queries
4. **XSS Prevention**: Content sanitization
5. **Session Management**: Secure session handling
6. **Authentication**: Session-based auth

---

## üí° T√ìM T·∫ÆT

**Lu·ªìng x·ª≠ l√Ω ho√†n ch·ªânh:**
```
User Input ‚Üí Frontend Validation ‚Üí API Call ‚Üí Rate Limiting ‚Üí 
Input Sanitization ‚Üí Language Detection ‚Üí Translation ‚Üí 
AI Context Building ‚Üí Intent Classification ‚Üí LLM Processing ‚Üí 
Action Parsing & Execution ‚Üí Response Generation ‚Üí Translation ‚Üí 
Database Storage ‚Üí Frontend Display
```

**C√°c c√°ch AI ph·∫£n h·ªìi:**
1. ‚úÖ Natural conversation
2. ‚úÖ Action-based responses
3. ‚úÖ Confirmation dialogues
4. ‚úÖ Information display
5. ‚úÖ Guidance & instructions
6. ‚úÖ Error messages
7. ‚úÖ Warning alerts
8. ‚úÖ Multi-step workflows
9. ‚úÖ Payment links
10. ‚úÖ Out-of-scope responses
11. ‚úÖ Page reload triggers


