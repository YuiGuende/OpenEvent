<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QdrantService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenEvent</a> &gt; <a href="index.source.html" class="el_package">com.group02.openevent.ai.qdrant.service</a> &gt; <span class="el_source">QdrantService.java</span></div><h1>QdrantService.java</h1><pre class="source lang-java linenums">package com.group02.openevent.ai.qdrant.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.group02.openevent.ai.util.ConfigLoader;
import lombok.extern.slf4j.Slf4j;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.net.URI;
import java.net.http.*;
import java.util.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.qdrant.client.grpc.Points.ScoredPoint;

/**
 * Service để tương tác với Qdrant vector database
 * @author Admin
 */
@Service
<span class="fc" id="L21">@Slf4j</span>
public class QdrantService {
    private final String baseUrl;
    private final String apiKey;
    private final String collection;
    private final int vectorSize; // Giữ lại như final

<span class="fc" id="L28">    private final HttpClient http = HttpClient.newHttpClient();</span>
<span class="fc" id="L29">    private final ObjectMapper om = new ObjectMapper();</span>

    // Constructor TIÊM (INJECT) các giá trị cấu hình từ Spring
    public QdrantService(
            @Value(&quot;${qdrant.url}&quot;) String baseUrl,
            @Value(&quot;${qdrant.api.key}&quot;) String apiKey,
            @Value(&quot;${qdrant.collection}&quot;) String collection,
            @Value(&quot;${qdrant.vector.size}&quot;) int vectorSize // Đảm bảo bạn có qdrant.vector.size trong config
<span class="fc" id="L37">    ) {</span>
<span class="fc" id="L38">        this.baseUrl = baseUrl.trim();</span>
<span class="fc" id="L39">        this.apiKey = apiKey.trim();</span>
<span class="fc" id="L40">        this.collection = collection.trim();</span>
<span class="fc" id="L41">        this.vectorSize = vectorSize;</span>
<span class="fc" id="L42">    }</span>


    @PostConstruct
    public void initializeIndexes() {
<span class="fc" id="L47">        log.info(&quot;Bắt đầu khởi tạo các chỉ mục (index) cần thiết cho Qdrant collection '{}'...&quot;, collection);</span>
        try {
            // Đảm bảo collection tồn tại trước khi tạo index
<span class="fc" id="L50">            ensureCollection();</span>

            // Tạo index cho các trường cần lọc để tăng tốc độ truy vấn
<span class="fc" id="L53">            createPayloadIndex(&quot;startsAt&quot;, &quot;integer&quot;);</span>
<span class="fc" id="L54">            createPayloadIndex(&quot;kind&quot;, &quot;keyword&quot;);</span>
<span class="fc" id="L55">            createPayloadIndex(&quot;place_id&quot;, &quot;integer&quot;); // Thêm index cho place_id nếu cần</span>

<span class="fc" id="L57">            log.info(&quot;✅ Hoàn tất khởi tạo chỉ mục cho Qdrant.&quot;);</span>
<span class="nc" id="L58">        } catch (Exception e) {</span>
            // Lỗi này thường xảy ra nếu index đã tồn tại, có thể bỏ qua một cách an toàn
<span class="nc" id="L60">            log.warn(&quot;⚠️ Không thể tạo chỉ mục Qdrant. Có thể chỉ mục đã tồn tại hoặc có lỗi kết nối. Lỗi: {}&quot;, e.getMessage());</span>
<span class="fc" id="L61">        }</span>
<span class="fc" id="L62">    }</span>

    // Gọi trước khi upsert/search
    public void ensureCollection() throws Exception {
<span class="fc" id="L66">        HttpRequest get = HttpRequest.newBuilder()</span>
<span class="fc" id="L67">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection))</span>
<span class="fc" id="L68">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="fc" id="L69">                .build();</span>
<span class="fc" id="L70">        HttpResponse&lt;String&gt; resp = http.send(get, HttpResponse.BodyHandlers.ofString());</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (resp.statusCode() == 200) return; // đã có</span>

        // tạo mới
<span class="nc" id="L74">        var body = Map.of(</span>
<span class="nc" id="L75">                &quot;vectors&quot;, Map.of(&quot;size&quot;, vectorSize, &quot;distance&quot;, &quot;Cosine&quot;)</span>
        );
<span class="nc" id="L77">        HttpRequest put = HttpRequest.newBuilder()</span>
<span class="nc" id="L78">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection))</span>
<span class="nc" id="L79">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L80">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="nc" id="L81">                .PUT(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(body)))</span>
<span class="nc" id="L82">                .build();</span>
<span class="nc" id="L83">        HttpResponse&lt;String&gt; created = http.send(put, HttpResponse.BodyHandlers.ofString());</span>
<span class="nc" id="L84">        requireOk(created, &quot;Tạo collection thất bại&quot;);</span>
<span class="nc" id="L85">    }</span>

    public String upsertEmbedding(String id, float[] embedding, Map&lt;String, Object&gt; payload) throws Exception {
<span class="nc" id="L88">        List&lt;Float&gt; vec = new ArrayList&lt;&gt;(embedding.length);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        for (float v : embedding) vec.add(v);</span>

        Object qId;
<span class="nc" id="L92">        try { qId = Long.valueOf(id); }</span>
<span class="nc" id="L93">        catch (NumberFormatException e) { qId = id; }</span>

<span class="nc" id="L95">        Map&lt;String, Object&gt; point = new HashMap&lt;&gt;();</span>
<span class="nc" id="L96">        point.put(&quot;id&quot;, qId);</span>
<span class="nc" id="L97">        point.put(&quot;vector&quot;, vec);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (payload != null) point.put(&quot;payload&quot;, payload);</span>

        // Gọi hàm upsert theo lô với danh sách chỉ có 1 point
<span class="nc" id="L101">        upsertPoints(List.of(point));</span>

<span class="nc" id="L103">        return &quot;{\&quot;status\&quot;:\&quot;ok\&quot;}&quot;;</span>
    }


    public List&lt;Map&lt;String,Object&gt;&gt; searchSimilarVectors(float[] queryVector, int limit) throws Exception {
<span class="nc" id="L108">        ensureCollection();</span>

<span class="nc" id="L110">        List&lt;Float&gt; vec = new ArrayList&lt;&gt;(queryVector.length);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (float v : queryVector) vec.add(v);</span>

<span class="nc" id="L113">        Map&lt;String,Object&gt; req = new HashMap&lt;&gt;();</span>
<span class="nc" id="L114">        req.put(&quot;vector&quot;, vec);</span>
<span class="nc" id="L115">        req.put(&quot;limit&quot;, limit);</span>
<span class="nc" id="L116">        req.put(&quot;with_payload&quot;, true);</span>

<span class="nc" id="L118">        HttpRequest httpReq = HttpRequest.newBuilder()</span>
<span class="nc" id="L119">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection + &quot;/points/search&quot;))</span>
<span class="nc" id="L120">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L121">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="nc" id="L122">                .POST(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(req)))</span>
<span class="nc" id="L123">                .build();</span>

<span class="nc" id="L125">        HttpResponse&lt;String&gt; resp = http.send(httpReq, HttpResponse.BodyHandlers.ofString());</span>
<span class="nc" id="L126">        requireOk(resp, &quot;Search lỗi&quot;);</span>

<span class="nc" id="L128">        JsonNode root = om.readTree(resp.body());</span>
<span class="nc" id="L129">        List&lt;Map&lt;String,Object&gt;&gt; out = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        for (JsonNode n : root.path(&quot;result&quot;)) {</span>
<span class="nc" id="L131">            Map&lt;String,Object&gt; m = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            m.put(&quot;id&quot;, n.path(&quot;id&quot;).isNumber() ? n.get(&quot;id&quot;).asLong() : n.get(&quot;id&quot;).asText());</span>
<span class="nc" id="L133">            m.put(&quot;score&quot;, n.path(&quot;score&quot;).asDouble());</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (n.has(&quot;payload&quot;)) m.put(&quot;payload&quot;, om.convertValue(n.get(&quot;payload&quot;), Map.class));</span>
<span class="nc" id="L135">            out.add(m);</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">        return out;</span>
    }
    /**
     * Tìm kiếm Vector với bộ lọc Metadata (Filtering).
     * Đây là hàm tổng quát được sử dụng bởi VectorIntentClassifier và EventVectorSearchService.
     * @param queryVector Vector tìm kiếm.
     * @param limit Số lượng kết quả.
     * @param filter Bộ lọc metadata Qdrant (dưới dạng Map&lt;String, Object&gt;).
     * @return Danh sách các điểm (point) Qdrant phù hợp.
     */
    public List&lt;Map&lt;String, Object&gt;&gt; searchSimilarVectorsWithFilter(
            float[] queryVector,
            int limit,
            Map&lt;String, Object&gt; filter) throws Exception {

<span class="nc" id="L152">        ensureCollection();</span>

<span class="nc" id="L154">        List&lt;Float&gt; vec = new ArrayList&lt;&gt;(queryVector.length);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (float v : queryVector) vec.add(v);</span>

<span class="nc" id="L157">        Map&lt;String, Object&gt; req = new HashMap&lt;&gt;();</span>
<span class="nc" id="L158">        req.put(&quot;vector&quot;, vec);</span>
<span class="nc" id="L159">        req.put(&quot;limit&quot;, limit);</span>
<span class="nc" id="L160">        req.put(&quot;with_payload&quot;, true);</span>

        // ÁP DỤNG BỘ LỌC TÙY CHỈNH
<span class="nc bnc" id="L163" title="All 4 branches missed.">        if (filter != null &amp;&amp; !filter.isEmpty()) {</span>
<span class="nc" id="L164">            req.put(&quot;filter&quot;, filter);</span>
        }

<span class="nc" id="L167">        HttpRequest httpReq = HttpRequest.newBuilder()</span>
<span class="nc" id="L168">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection + &quot;/points/search&quot;))</span>
<span class="nc" id="L169">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L170">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="nc" id="L171">                .POST(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(req)))</span>
<span class="nc" id="L172">                .build();</span>

<span class="nc" id="L174">        HttpResponse&lt;String&gt; resp = http.send(httpReq, HttpResponse.BodyHandlers.ofString());</span>
<span class="nc" id="L175">        requireOk(resp, &quot;Search lỗi (có filter)&quot;);</span>

        // Tái sử dụng logic parse kết quả JSON
<span class="nc" id="L178">        JsonNode root = om.readTree(resp.body());</span>
<span class="nc" id="L179">        List&lt;Map&lt;String,Object&gt;&gt; out = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (JsonNode n : root.path(&quot;result&quot;)) {</span>
<span class="nc" id="L181">            Map&lt;String,Object&gt; m = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            m.put(&quot;id&quot;, n.path(&quot;id&quot;).isNumber() ? n.get(&quot;id&quot;).asLong() : n.get(&quot;id&quot;).asText());</span>
<span class="nc" id="L183">            m.put(&quot;score&quot;, n.path(&quot;score&quot;).asDouble());</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (n.has(&quot;payload&quot;)) m.put(&quot;payload&quot;, om.convertValue(n.get(&quot;payload&quot;), Map.class));</span>
<span class="nc" id="L185">            out.add(m);</span>
<span class="nc" id="L186">        }</span>
<span class="nc" id="L187">        return out;</span>
    }

    private void requireOk(HttpResponse&lt;String&gt; resp, String msg) {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (resp.statusCode() != 200) throw new RuntimeException(msg + &quot;: HTTP &quot; + resp.statusCode() + &quot; - &quot; + resp.body());</span>
        try {
<span class="fc" id="L193">            JsonNode root = om.readTree(resp.body());</span>
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">            if (root.has(&quot;status&quot;) &amp;&amp; !root.path(&quot;status&quot;).path(&quot;error&quot;).isNull()</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">                    &amp;&amp; !root.path(&quot;status&quot;).path(&quot;error&quot;).asText().isEmpty()) {</span>
<span class="nc" id="L196">                throw new RuntimeException(msg + &quot;: &quot; + root.path(&quot;status&quot;).path(&quot;error&quot;).asText());</span>
            }
<span class="pc" id="L198">        } catch (Exception ignore) { /* nếu body không phải JSON hợp lệ, đã check statusCode ở trên */ }</span>
<span class="fc" id="L199">    }</span>
    /**
     * Tìm kiếm các địa điểm Place gần nhất bằng Vector Search trong Qdrant.
     */
    public List&lt;Map&lt;String, Object&gt;&gt; searchPlacesByVector(float[] queryVector, int limit) throws Exception {
        // 1. Chuẩn bị Vector
<span class="nc" id="L205">        List&lt;Float&gt; vec = new ArrayList&lt;&gt;(queryVector.length);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (float v : queryVector) vec.add(v);</span>

<span class="nc" id="L208">        Map&lt;String, Object&gt; req = new HashMap&lt;&gt;();</span>
<span class="nc" id="L209">        req.put(&quot;vector&quot;, vec);</span>
<span class="nc" id="L210">        req.put(&quot;limit&quot;, limit);</span>
<span class="nc" id="L211">        req.put(&quot;with_payload&quot;, true);</span>

        // THÊM FILTER: Nếu bạn có payload &quot;kind:place&quot; trong Qdrant
        // req.put(&quot;filter&quot;, Map.of(&quot;must&quot;, List.of(Map.of(&quot;key&quot;, &quot;kind&quot;, &quot;match&quot;, Map.of(&quot;value&quot;, &quot;place&quot;)))));
<span class="nc" id="L215">        Map&lt;String, Object&gt; filter = Map.of(</span>
<span class="nc" id="L216">                &quot;must&quot;, List.of(</span>
                        // Yêu cầu trường 'kind' trong payload phải có giá trị là 'place'
<span class="nc" id="L218">                        Map.of(&quot;key&quot;, &quot;kind&quot;, &quot;match&quot;, Map.of(&quot;value&quot;, &quot;place&quot;))</span>
                )
        );
<span class="nc" id="L221">        req.put(&quot;filter&quot;, filter); // &lt;-- Thêm bộ lọc vào request</span>

        // 2. Gọi API Qdrant (Sử dụng logic từ searchSimilarVectors)
<span class="nc" id="L224">        HttpRequest httpReq = HttpRequest.newBuilder()</span>
<span class="nc" id="L225">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection + &quot;/points/search&quot;))</span>
<span class="nc" id="L226">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L227">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="nc" id="L228">                .POST(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(req)))</span>
<span class="nc" id="L229">                .build();</span>

<span class="nc" id="L231">        HttpResponse&lt;String&gt; resp = http.send(httpReq, HttpResponse.BodyHandlers.ofString());</span>

        // Tái sử dụng logic kiểm tra lỗi và parsing JSON từ searchSimilarVectors
<span class="nc" id="L234">        requireOk(resp, &quot;Search Places lỗi&quot;);</span>

        // Logic parse JSON (Giống hệt searchSimilarVectors)
<span class="nc" id="L237">        JsonNode root = om.readTree(resp.body());</span>
<span class="nc" id="L238">        List&lt;Map&lt;String,Object&gt;&gt; out = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        for (JsonNode n : root.path(&quot;result&quot;)) {</span>
<span class="nc" id="L240">            Map&lt;String,Object&gt; m = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            m.put(&quot;id&quot;, n.path(&quot;id&quot;).isNumber() ? n.get(&quot;id&quot;).asLong() : n.get(&quot;id&quot;).asText());</span>
<span class="nc" id="L242">            m.put(&quot;score&quot;, n.path(&quot;score&quot;).asDouble());</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (n.has(&quot;payload&quot;)) m.put(&quot;payload&quot;, om.convertValue(n.get(&quot;payload&quot;), Map.class));</span>
<span class="nc" id="L244">            out.add(m);</span>
<span class="nc" id="L245">        }</span>
<span class="nc" id="L246">        return out;</span>
    }
    /**
     * Tạo Payload Index cho một key cụ thể (ví dụ: 'kind') để tối ưu hóa việc lọc.
     */
    public void createPayloadIndex(String fieldName, String fieldType) throws Exception {
<span class="fc" id="L252">        String indexUrl = baseUrl + &quot;/collections/&quot; + collection + &quot;/index&quot;;</span>

<span class="fc" id="L254">        var body = Map.of(</span>
                &quot;field_name&quot;, fieldName,
                &quot;field_schema&quot;, fieldType, // Ví dụ: &quot;keyword&quot; hoặc &quot;integer&quot;
<span class="fc" id="L257">                &quot;wait&quot;, true</span>
        );

<span class="fc" id="L260">        HttpRequest request = HttpRequest.newBuilder()</span>
<span class="fc" id="L261">                .uri(URI.create(indexUrl))</span>
<span class="fc" id="L262">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="fc" id="L263">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="fc" id="L264">                .PUT(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(body)))</span>
<span class="fc" id="L265">                .build();</span>

<span class="fc" id="L267">        HttpResponse&lt;String&gt; resp = http.send(request, HttpResponse.BodyHandlers.ofString());</span>
<span class="fc" id="L268">        requireOk(resp, &quot;Tạo Payload Index thất bại cho key: &quot; + fieldName);</span>
<span class="fc" id="L269">    }</span>
    /**
     * ✅ PHƯƠNG THỨC MỚI QUAN TRỌNG:
     * Upsert một danh sách các điểm (points) lên Qdrant trong một lần gọi API duy nhất.
     */
    public void upsertPoints(List&lt;Map&lt;String, Object&gt;&gt; points) throws Exception {
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if (points == null || points.isEmpty()) {</span>
<span class="nc" id="L276">            log.warn(&quot;upsertPoints được gọi với danh sách rỗng, bỏ qua.&quot;);</span>
<span class="nc" id="L277">            return;</span>
        }

<span class="nc" id="L280">        ensureCollection();</span>

        // Body của request sẽ chứa một danh sách các point trong key &quot;points&quot;
<span class="nc" id="L283">        Map&lt;String, Object&gt; req = Map.of(&quot;points&quot;, points);</span>

<span class="nc" id="L285">        HttpRequest request = HttpRequest.newBuilder()</span>
<span class="nc" id="L286">                .uri(URI.create(baseUrl + &quot;/collections/&quot; + collection + &quot;/points?wait=true&quot;)) // wait=true để đảm bảo dữ liệu được ghi xong</span>
<span class="nc" id="L287">                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L288">                .header(&quot;api-key&quot;, apiKey)</span>
<span class="nc" id="L289">                .PUT(HttpRequest.BodyPublishers.ofString(om.writeValueAsString(req)))</span>
<span class="nc" id="L290">                .build();</span>

<span class="nc" id="L292">        HttpResponse&lt;String&gt; resp = http.send(request, HttpResponse.BodyHandlers.ofString());</span>
<span class="nc" id="L293">        requireOk(resp, &quot;Lỗi khi upsert theo lô (batch upsert)&quot;);</span>
<span class="nc" id="L294">        log.info(&quot;✅ Upsert thành công {} points vào collection '{}'&quot;, points.size(), collection);</span>
<span class="nc" id="L295">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>